# C_ID 103411:Mini Pascal 

61454 | Umm e Aiman
60697 | Rubab Khan 

## Project Description ##
Compiler verifies whether or not the tokens generated by the lexical analyzer are grouped according to the  rules of the language. This is done by a mini parser. The parser obtains a string of tokens from the lexical analyzer and verifies that the string can be the grammar for the source language.
## Sample Language Used 
Mini Pascal 
### Sample construct of language:
Program Lessonl_Program3;
var
Numl, Num2, Sum : Integer; 
Begin {no semicolon}
      Write('Input number 1:');
      Readln(Numl);
      Writeln('Input number 2:');
      Readln(Num2); Sum := Numl + Num2; {addition}
      writeln(Sum); Readln; 
End. 


if condition
     then true_statement 
     else false_statement; 
if boolean_condition then 
begin 
      statement_zero;
      statement one;
      statement_two;
end; 


a := 5;
while a < 6 do 
begin
  writeln (a);
  a := a + 1 
  end; 
  
sum := 0;
for count := 1 to 100 do 
begin 
  sum := sum + count; 
  if sum = 38 then break;
end;

for index :=StratingtHigh downto EndingLow do
   statement;

### Lexical Specification###
#### Syntax of Mini-Pascal (Welsh & McKeag, 1980)####
Syntax in recursive descent order

<program> ::= program <identifier> ; <block> .
<block> ::= <variable declaration part>
            <procedure declaration part>
            <statement part>
  
<variable declaration part> ::= <empty> |
            var <variable declaration> ;
            { <variable declaration> ; }
<variable declaration> ::= <identifier > { , <identifier> } : <type>
<type> ::= <simple type> | <array type>
<array type> ::= array [ <index range> ] of <simple type>
<index range> ::= <integer constant> .. <integer constant>
<simple type> ::= <type identifier>
<type identifier> ::= <identifier>

<procedure declaration part> ::= { <procedure declaration> ; }
<procedure declaration> ::= procedure <identifier> ; <block>

<statement part> ::= <compound statement>
<compound statement> ::= begin <statement>{ ; <statement> } end
<statement> ::= <simple statement> | <structured statement

<simple statement> ::= <assignment statement> | <procedure statement> |
<read statement> | <write statement>
<assignment statement> ::= <variable> := <expression>
<procedure statement> ::= <procedure identifier>
<procedure identifier> ::= <identifier>
<read statement> ::= read ( <input variable> { , <input variable> } )
<input variable> ::= <variable>
<write statement> ::= write ( <output value> { , <output value> } )
<output value> ::= <expression>

<structured statement>::= <compound statement> | <if statement>|<while statement>
<if statement>::= if <expression> then <statement> |
                  if <expression> then <statement> else <statement>
<while statement> ::= while <expression> do <statement>

<expression> ::= <simple expression> |
                 <simple expression> <relational operator> <simple expression>
<simple expression> ::= <sign> <term> { <adding operator> <term> }
<term> ::= <factor> { <multiplying operator> <factor> }
<factor> ::= <variable> | <constant> | ( <expression> ) | not <factor>


<relational operator> ::= = | <> | < | <= | >= | >
<sign> ::= + | - | <empty>
<adding operator> ::= + | - | or
<multiplying operator> ::= * | div | and


<variable> ::= <entire variable> | <indexed variable>
<indexed variable> ::= <array variable> [ <expression> ]
<array variable> ::= <entire variable>
<entire variable> ::= <variable identifier>
<variable identifier> ::= <identifier>


### Grammar###
<constant> ::= <integer constant> | <character constant> | <constant identifier>
<constant identifier> ::= <identifier>
<identifier> ::= <letter> { <letter or digit> }
<letter or digit> ::= <letter> | <digit>
<integer constant> ::= <digit> { <digit> }
<character constant> ::= '< any character other than ' >' | ''''
  <letter> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P
| Q | R | S | T | U | V | W | X | Y | Z
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<special symbol> ::= + | - | * | = | <> | < | > | <= | >= |
( | ) | [ | ] | := | . | , | ; | : | .. | div | or |
and | not | if | then | else | of | while | do | begin | end | read | write | var | array | procedure | program
<predefined identifier> ::= integer | Boolean | true | false
 
 ### Context free grammer###
  #### Mini PASCAL Grammar#### 
  program → 
  program id ( identifier list ) ; 
  declarations
  subprogram_declarations 
  compound_statement
   
  identifier list →
  id 
  | identifier_list , id 
  
  declarations →
             declarations var identifier list : type ; 
             | E
   type→
        standard_type
        | array [ num .. num ] of standard_type 
 Standard_type → 
integer
| real 
Subprogram_declarations → 
         subprogram_declarations subprogram_declarion ;
          | E 
Subprogram_declaration → 
         subprogram_head declarations compound_statement
subprogram_head → 
          function id arguments : standard type ;
          | procedure id arguments ;
 arguments → 
           ( parameter_list )
           | E
 Parameter_list → 
           Identifier_list : type 
           | parameter list ; identifier list : type
           compound statement → 
           begin
           optional_statements
           end 
           optional_statements →
           statement_list
           | E
  Statement_list → 
           statement 
           | statement list ; statement
statement → 
           variable assignop expression
           | procedure_statement 
           | compound_statement
           | if expression then statement else statement
           | while expression do statement
 variable → 
           id 
           | id [ expression ]
Procedure_statement → 
          id
          | id ( expression_list ) 
Expression_list → 
          expression
          | expression_list , expression
expression →
          simple_expression 
         | simple_expression relop simple_expression
simple expression →
          term
          | sign term 
          | simple_expression addop term 
term → 
          factor 
          | term mulop factor 
factor →
          id 
          | id ( expression_list ) 
          | num 
          ( expression )
          | not factor 
sign → 
           + |−

	 

### Problems Faced
The problem we have faced in working on new language which we had never work before and to learn these language we have faced many difficulties because we are not using these languages on daily basis, also it is difficult to gather data from internet regarding these language.

### References

- https://github.com/rccoder/Mini-Pascal-Compiler

- https://www.youtube.com/watch?v=Hw4GEwhCZpc 

- https://www.geeksforgeeks.org/recursive-descent-parser/

